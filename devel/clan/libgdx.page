---
toc: yes
title: libgdx
...

ここは [../clan]() の子ページですが、Javaのlibgdxユーザにも有益だと思うので、コード類はJava表現で書くようにします。


# 基本

- [http://libgdx.badlogicgames.com/features.html]() によると、「Libgdx tries not be the "end all, be all" solution. It does not force a specific design on you. Pick and choose from the features below.(以下の表は省略)」との事。この方針によって、同様の他のフレームワークやゲームエンジンよりもずっと自由度が高い。「clojure経由でlibgdxを使おう」みたいな事を考える者にとってはこの自由度は重要な点だ。他の「全部入り」指向のフレームワークは(たとえそれが安全の為であっても)制限が多い。

- 分からない事があれば、とりあえず[Wiki](http://code.google.com/p/libgdx/wiki/TableOfContents)に該当記事がないか探してみる。それなりに頻繁に更新されている。

- 時間がある時に一度、どんな機能があるかを[API](http://libgdx.badlogicgames.com/nightlies/docs/api/)のところから目を通しておいた方がいい。必要な機能が既に実装されている事は多い。
    - 勿論、エディタのリファレンス機能もしくは[検索ディスパッチャ](http://doc.intra.tir.ne.jp/devel/env/windows#%E9%96%8B%E7%99%BA%E7%94%A8%E3%82%BD%E3%83%95%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB)にも、このAPIからの検索を登録しておく事。頻繁に使う事になる。


# ライフサイクル

- androidの[Activity Lifecycle](http://developer.android.com/intl/ja/reference/android/app/Activity.html#ActivityLifecycle)はかなり複雑。しかしandroidアプリを作る上で避けては通れない。

- libgdxの[ApplicationLifeCycle](http://code.google.com/p/libgdx/wiki/ApplicationLifeCycle)は上記androidのlifecycleを扱いやすいようにシンプルにされている(それでいて必要最小限の分離が保たれている)。しかしその代償として分かりにくい部分が増えている箇所があるのと、元々分かりにくい部分も多い為、以下に注意点をまとめてみた。
    - この図ではrender()とひとくくりにされているが、render()の中ではスクリーン等への描画のみではなく、各種の入力値の反映や内部処理も同時に行う必要がある。実際の処理のほとんどはここに書く事になる。
    - PCではpause()→resume()の流れは絶対に起きない為、この部分の動作検証は実機もしくはエミュレータで行うしかない。
    - resume()はこの図を見る限りでは特別な処理はほとんどいらないように見えるが実際はそうではない。詳細は後述の[#glコンテキストの喪失]()を参照。
    - この図ではpause()→resume()の間は何も呼ばれないように見えるが、実際にはこの間の中でresize()が呼ばれうる。この為、resize()はresume()に依存してはならないし、resume()もresize()に依存してはならない。
    - この図では分かりにくいが、実機では普通に「ホームボタンを押されてpause()は実行されたものの、続きが再開される前に本体再起動されてdispose()は呼ばれない」のような事が起こりうる。つまりデータの保存はpause()で行わなくてはならない。
    - 後述のdexキャッシュ問題の為に、きちんとdispose()まで呼ばれて終了したプロセスであっても、パッケージ空間によっては、次回起動時のcreate()時点で、前回実行時の変数などが残っている現象が起こる(具体的にはActivityに指定されている以外のクラスのstatic変数がやばい？もう少し調査が必要)。
        - また逆に起動中に変数が`<clinit>`か何かによってクリアされる現象も起こるらしい(これは自分は未確認)。
            - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
        - とにかくstatic変数は注意をした方がいいようだ。
    - render()内で捕捉されない例外が発生した場合、pause()もdispose()も呼ばれない。これは普通によろしくないので、render()内で例外が発生したら一旦catchし、手でpause()を実行してからrethrowするようにした方がいい。
        - dispose()は前述の通り、正常動作時であっても呼ばれない事があるので、エラー終了する時には実行しなくていいと思う。
        - render()以外での例外の捕捉について
            - create(), dispose()内では当然この処理はいらない
            - resume(), pause()内では例外を捕捉してdispose()を呼ぶ事はできるけれども前述の通り必須ではない
            - resize()は前述の通りpause()→resume()の間に実行されうるので、「例外が出たら常にpause()しとけばいい」という訳にはいかない
                - そんな実装をしてしまったら、例外発生時のみとは言え、pause()が二回連続で実行される状況が起こり、pause()内での処理によっては破滅的な現象が起こりうる
                - 例外発生時でもpause()が一回だけ呼ばれるよう、きちんとフラグ等による判定を行う事。もしそれが面倒なら「resize()内での例外発生時はpause()は呼ばない」実装の方がまだマシだろう


# androidのdexキャッシュ問題

- 二回目起動時に、トップレベルのdefで定義した、以前に起動したプロセスの変数の内容が残っている。本体を起動するとなくなる
    - これはどうも、(android版)clojure固有の特性のようです。javaでは再現しない？
    - javaでは同じ問題が起こった時、単にstaticイニシャライザによって初期化されるだけなので、この現象は起こらないようだ。
        - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
    - この挙動が起こるか起こらないかは、Activityに指定されているクラスかそうでないかで決まる？もう少し調査が必要…
    - この挙動が保証されたものであるなら便利に使えるが、そうでないなら利用するのは危険である。

- 上記に関連して、二回目起動時にはロードされたクラスはキャッシュされる為、clojureの初期化処理等は非常に早く終わる(PCよりも早い)。


# GLコンテキストの喪失

- android実機にて、アプリ起動中にホームボタンを押したり別アプリを開いたりして、その後にまた戻ってきた時には上のライフサイクルでの「pause()→resume()」が発生する。この時に、AndroidゲームプログラミングA to Zのp.270に書いてある「GLコンテキストの喪失」が起こる。この現象ではPCでは起こせない。
    - 要はOpenGL内に反映させたデータが全部消えるという現象。
    - この時に、ファイルからコンストラクトしたTextureは自動的に再生成されるようになっているが、そうではない、Pixmap等から動的に生成したTextureは再生成されない。
    - またこの時に、Texture内部idの再配布(再利用あり)が行われる為、前述の「再生成されなかったTexture」は、再読み込みされたTextureのどれかが割り当たる現象が起こる
        - 正確には違うかも。しかしとにかく内部のtexture idがおかしくなる
    - どうするのが正解かというと、これらの「GLコンテキストの喪失」によっておかしくなるインスタンスは全て「resume()時に生成」し「pause()時に破棄」するようにすべき。そして上のライフサイクル図を見てもらえば分かるが、起動直後はresume()は呼ばれないので、create()の最後に自分でresume()を呼んでしまうのがよい。


# その他

- postRunnable()で渡したコードの実行時に例外が出ると、スタックトレースは出るがプロセスは死なないようだ。

- Gdx.input.justTouched() と Gdx.input.isTouched() は、実機では稀に不整合状態になるタイミングがあるようだ。
    - おそらくだが、どちらかもしくは両方がリアルタイムでの判定の為、実際にそれぞれの結果を取得/変数保存するタイミングにずれがあり、その間に状態が変化すると、不整合状態になるのではと思う。
    - 対策は色々あると思うが「ある一つの判定処理内にて、両方を同時に使う事がないようにコードを組む」のが一番簡単だと思う。

- libgdxでは基本的に小数は全部floatなので、引数エラーになったら数値のうしろにfをつけたり、変数の前に(float)をつけたりしてみる。

- Preferences のデータの保存先
    - androidでは、androidのSharedPreferences内。
        - 仕様上では最大8kとなっているが、実質的には最大2k程度。
    - windowsでは、 `C:\Users\{USERNAME}\.prefs\{PREFNAME}\` 内。
        - androidとは違い、他のlibgdx利用アプリと共通なので、
          PREFNAMEはきちんとuniqueな名前にする必要がある！
    - windows以外のdesktopでは、 `~/.prefs/{PREFNAME}/` 内。
        - PREFNAMEについてはwindowsと同じ注意が必要！

- [assets]() にも少し関連情報を書いた

余裕があればチュートリアル的なものも書きたいが…そんな余裕はない！


<!-- vim:set ft=pandoc ts=4 sts=4 sw=4 et: -->
