---
toc: yes
title: libgdx
...

ここは [../clan]() の子ページですが、Javaのlibgdxユーザにも有益だと思うので、コード類はJava表現で書くようにします。


# 基本

- 分からない事があれば、とりあえず[Wiki](http://code.google.com/p/libgdx/wiki/TableOfContents)に該当記事がないか探してみる。それなりに頻繁に更新されている。

- 時間がある時に一度、どんな機能があるかを[API](http://libgdx.badlogicgames.com/nightlies/docs/api/)のところから目を通しておいた方がいい。必要な機能が既に実装されている事は多い。
    - また、[検索ディスパッチャ](http://doc.intra.tir.ne.jp/devel/env/windows#%E9%96%8B%E7%99%BA%E7%94%A8%E3%82%BD%E3%83%95%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB)にも、このAPIからの検索を登録しておく事。頻繁に使う事になる。


# ライフサイクル

- androidの[Activity Lifecycle](http://developer.android.com/intl/ja/reference/android/app/Activity.html#ActivityLifecycle)はかなり複雑。しかしandroidアプリを作る上で避けては通れない。

- libgdxの[ApplicationLifeCycle](http://code.google.com/p/libgdx/wiki/ApplicationLifeCycle)はandroidのlifecycleを扱いやすいようにある程度簡潔化してある。しかしこれはこれで不完全な部分があり注意しなくてはならない。
    - この図ではrender()とひとくくりにされているが、この中では「(タッチスクリーンや各種センサーによる)外部入力からの状態変更」「外部入力によらない、計算もしくは時間経過からの状態変更」「スクリーン(もしくはサウンド等も含む)への出力」の三種別の処理を行う必要がある。いっしょくたでも別に動作に問題はないが分けた方がコーディングしやすいと思う。
    - render()内で補足されない例外が発生した場合、pause()もdispose()も呼ばれない。これは普通によろしくないので、render()内で例外が発生したら一旦catchし、pause()とdispose()を実行してからrethrowするようにした方がいいと思う。
    - PCではpause()→resume()の流れは絶対に起きない為、この部分の動作検証は実機もしくはエミュレータで行うしかない。
    - resume()は一見、特に処理がいらないように見えるが、このタイミングにて後述の「GLコンテキストの喪失」が起こる為、普通に考えたらcreate()内で確保すればよさそうに思えるインスタンスであっても、「GLコンテキストの喪失」の影響を受けるインスタンスはresume()内で生成するようにし、そして「create()の最後でresume()を呼ぶ」ようにした方がよい！またそれに伴い、これらのインスタンスはdispose()時ではなく、pause()時に破棄すべき。
    - この図ではpause()→resume()の間は何も呼ばれないように見えるが、実際にはこのタイミング近辺にてresize()が呼ばれうる。この為、resize()はresume()に依存してはならないし、resume()もresize()に依存してはならない。
    - この図では分かりにくいが、実機では普通に、「ホームボタンを押されてpause()は実行されたものの、続きが再開される前に本体再起動」のような事が起こりうる事に注意する。つまりデータの保存はpause()で行わなくてはならない。
    - また、後述のdexキャッシュ問題の為に、きちんとdispose()まで呼ばれて終了したプロセスであっても、パッケージ空間によっては、次回起動時のcreate()時点で、前回実行時の変数などが残っている現象が起こる(具体的にはActivityに指定されている以外のクラスのstatic変数がやばいようだ)。
        - また逆に起動中に変数が`<clinit>`か何かによってクリアされる現象も起こるらしい(これは自分は未確認)。
            - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
        - とにかくstatic変数は注意をした方がいいようだ。


# androidのdexキャッシュ問題

- 二回目起動時に、トップレベルのdefで定義した、以前に起動したプロセスの変数の内容が残っている。本体を起動するとなくなる
    - これはどうも、(android版)clojure固有の特性のようです。javaでは再現しない？
    - javaでは同じ問題が起こった時、単にstaticイニシャライザによって初期化されるだけなので、この現象は起こらないようだ。
        - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
    - この挙動が起こるか起こらないかは、Activityに指定されているクラスかそうでないかで決まる？もう少し調査が必要…
    - この挙動が保証されたものであるなら便利に使えるが、そうでないなら利用するのは危険である。

- 上記に関連して、二回目起動時にはロードされたクラスはキャッシュされる為、clojureの初期化処理等は非常に早く終わる(PCよりも早い)。


# GLコンテキストの喪失

- android実機にて、アプリ起動中にホームボタンを押したり別アプリを開いたりして、その後にまた戻ってきた時には上のライフサイクルでの「pause()→resume()」が発生する。この時に、AndroidゲームプログラミングA to Zのp.270に書いてある「GLコンテキストの喪失」が起こる。この現象ではPCでは起こせない。
    - 要はOpenGL内に反映させたデータが全部消えるという現象。
    - この時に、ファイルからコンストラクトしたTextureは自動的に再生成されるようになっているが、そうではない、Pixmap等から動的に生成したTextureは再生成されない。
    - またこの時に、Texture内部idの再配布(再利用あり)が行われる為、前述の「再生成されなかったTexture」は、再読み込みされたTextureのどれかが割り当たる現象が起こる
        - 正確には違うかも。しかしとにかく内部のtexture idがおかしくなる
    - どうするのが正解かというと、これらの「GLコンテキストの喪失」によっておかしくなるインスタンスは全て「resume()時に生成」し「pause()時に破棄」するようにすべき。そして上のライフサイクル図を見てもらえば分かるが、起動直後はresume()は呼ばれないので、create()の最後にでも自分でresume()を呼んでしまうのがよい。


# その他

- Gdx.input.justTouched() と Gdx.input.isTouched() は、実機では稀に不整合状態になるタイミングがあるようだ。
    - おそらくだが、どちらかもしくは両方がリアルタイムでの判定の為、実際にそれぞれの結果を取得/変数保存するタイミングにずれがあり、その間に状態が変化すると、不整合状態になるのではと思う。
    - 対策は色々あると思うが「ある一つの判定処理内にて、両方を同時に使う事がないようにコードを組む」のが一番簡単だと思う。

- libgdxでは基本的に小数は全部floatなので、引数エラーになったら数値のうしろにfをつけたり、変数の前に(float)をつけたりしてみる。

- Preferences のデータの保存先
    - androidでは、androidのSharedPreferences内。
        - 仕様上では最大8kとなっているが、実質的には最大2k程度。
    - windowsでは、 `C:\Users\{USERNAME}\.prefs\{PREFNAME}\` 内。
        - androidとは違い、他のlibgdx利用アプリと共通なので、
          PREFNAMEはきちんとuniqueな名前にする必要がある！
    - windows以外のdesktopでは、 `~/.prefs/{PREFNAME}/` 内。
        - PREFNAMEについてはwindowsと同じ注意が必要！

- [assets]() にも少し関連情報を書いた

余裕があればチュートリアル的なものも書きたいが…そんな余裕はない！


<!-- vim:set ft=pandoc ts=4 sts=4 sw=4 et: -->
