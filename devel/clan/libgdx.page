---
toc: yes
title: libgdx
...

ここは [../clan]() の子ページですが、Javaのlibgdxユーザにも有益だと思うので、コード類はJava表現で書くようにします。


# 基本

- [http://libgdx.badlogicgames.com/features.html]() によると、「Libgdx tries not be the "end all, be all" solution. It does not force a specific design on you. Pick and choose from the features below.(以下の表は省略)」との事。この方針によって、同様の他のフレームワークやゲームエンジンよりもずっと自由度が高い。しかしこの自由度の高さには勿論「自分の足を撃つ自由」も含まれている為、注意すべき点も結構ある。それでも「clojure経由でlibgdxを使おう」みたいな事を考える者にとってはこの自由度は本当に重要だ。他の「全部入り」指向のフレームワークは(たとえそれが安全の為であっても)制限が多い。

- 分からない事があれば、とりあえず[Wiki](http://code.google.com/p/libgdx/wiki/TableOfContents)に該当記事がないか探してみる。それなりに頻繁に更新されている。

- 時間がある時に一度、どんな機能があるかを[API](http://libgdx.badlogicgames.com/nightlies/docs/api/)のところから目を通しておいた方がいい。必要な機能が既に実装されている事は多い。
    - 勿論、エディタのリファレンス機能もしくは[検索ディスパッチャ](http://doc.intra.tir.ne.jp/devel/env/windows#%E9%96%8B%E7%99%BA%E7%94%A8%E3%82%BD%E3%83%95%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB)にも、このAPIからの検索を登録しておく事。頻繁に使う事になる。


# ライフサイクル

- androidの[Activity Lifecycle](http://developer.android.com/intl/ja/reference/android/app/Activity.html#ActivityLifecycle)はかなり複雑。しかしandroidアプリを作る上で避けては通れない。

- libgdxの[ApplicationLifeCycle](http://code.google.com/p/libgdx/wiki/ApplicationLifeCycle)は上記androidのlifecycleを扱いやすいようにシンプルにされている(それでいて必要最小限の分離が保たれている)。しかしその代償として分かりにくい部分が増えている箇所があるのと、元々分かりにくい部分も多い為、以下に注意点をまとめてみた。
    - この図ではrender()とひとくくりにされているが、この中では「タッチスクリーンや各種センサーによる、ユーザ操作由来の外部入力からの状態変更」「前述の外部入力によらない、内部処理や時間経過からの状態変更」「スクリーン(もしくはサウンド等も含む)への出力」の三種別の処理を行う必要がある。これらがいっしょくたでも別に動作に問題はないが分けた方がコードのメンテがしやすいと思う。
    - render()内で補足されない例外が発生した場合、pause()もdispose()も呼ばれない。これは普通によろしくないので、render()内で例外が発生したら一旦catchし、手でpause()を実行してからrethrowするようにした方がいいと思う。
        - dispose()は後述するように、正常動作時であっても呼ばれない事があるので、エラー終了する時には実行しなくていいと思う。
        - 「render()だけではなく、resize()とかでも必要では？」という疑問があるかもしれない。しかしcreate(), dispose()内では当然この処理はいらないし、pause(), resume()内では例外を補足してdispose()を呼ぶ事はできるけれども前述の通り必須ではない。残るはresize()だが、これも後述するようにpause()→resume()の間に実行されうるので「常にpause()しとけばいい」という訳にはいかない。きちんと行うなら「このresize()呼び出しは、pause()→resume()の間での実行か？」という判定を行った上でpause()を呼ぶべきだけど、面倒ならresize()は例外の補足はなしでもいいと思う(pause()二回実行はやばい場合があるので「常にpause()する」実装はしない事！)。
    - PCではpause()→resume()の流れは絶対に起きない為、この部分の動作検証は実機もしくはエミュレータで行うしかない。
    - resume()はこの図を見る限りでは特別な処理はほとんどいらないように見えるが実際はそうではない。詳細は後述の[#glコンテキストの喪失]()を参照。
    - この図ではpause()→resume()の間は何も呼ばれないように見えるが、実際にはこの間の中でresize()が呼ばれうる。この為、resize()はresume()に依存してはならないし、resume()もresize()に依存してはならない。
    - この図では分かりにくいが、実機では普通に「ホームボタンを押されてpause()は実行されたものの、続きが再開される前に本体再起動されてdispose()は呼ばれない」のような事が起こりうる。つまりデータの保存はpause()で行わなくてはならない。
    - 後述のdexキャッシュ問題の為に、きちんとdispose()まで呼ばれて終了したプロセスであっても、パッケージ空間によっては、次回起動時のcreate()時点で、前回実行時の変数などが残っている現象が起こる(具体的にはActivityに指定されている以外のクラスのstatic変数がやばい？もう少し調査が必要)。
        - また逆に起動中に変数が`<clinit>`か何かによってクリアされる現象も起こるらしい(これは自分は未確認)。
            - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
        - とにかくstatic変数は注意をした方がいいようだ。


# androidのdexキャッシュ問題

- 二回目起動時に、トップレベルのdefで定義した、以前に起動したプロセスの変数の内容が残っている。本体を起動するとなくなる
    - これはどうも、(android版)clojure固有の特性のようです。javaでは再現しない？
    - javaでは同じ問題が起こった時、単にstaticイニシャライザによって初期化されるだけなので、この現象は起こらないようだ。
        - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
    - この挙動が起こるか起こらないかは、Activityに指定されているクラスかそうでないかで決まる？もう少し調査が必要…
    - この挙動が保証されたものであるなら便利に使えるが、そうでないなら利用するのは危険である。

- 上記に関連して、二回目起動時にはロードされたクラスはキャッシュされる為、clojureの初期化処理等は非常に早く終わる(PCよりも早い)。


# GLコンテキストの喪失

- android実機にて、アプリ起動中にホームボタンを押したり別アプリを開いたりして、その後にまた戻ってきた時には上のライフサイクルでの「pause()→resume()」が発生する。この時に、AndroidゲームプログラミングA to Zのp.270に書いてある「GLコンテキストの喪失」が起こる。この現象ではPCでは起こせない。
    - 要はOpenGL内に反映させたデータが全部消えるという現象。
    - この時に、ファイルからコンストラクトしたTextureは自動的に再生成されるようになっているが、そうではない、Pixmap等から動的に生成したTextureは再生成されない。
    - またこの時に、Texture内部idの再配布(再利用あり)が行われる為、前述の「再生成されなかったTexture」は、再読み込みされたTextureのどれかが割り当たる現象が起こる
        - 正確には違うかも。しかしとにかく内部のtexture idがおかしくなる
    - どうするのが正解かというと、これらの「GLコンテキストの喪失」によっておかしくなるインスタンスは全て「resume()時に生成」し「pause()時に破棄」するようにすべき。そして上のライフサイクル図を見てもらえば分かるが、起動直後はresume()は呼ばれないので、create()の最後にでも自分でresume()を呼んでしまうのがよい。


# その他

- Gdx.input.justTouched() と Gdx.input.isTouched() は、実機では稀に不整合状態になるタイミングがあるようだ。
    - おそらくだが、どちらかもしくは両方がリアルタイムでの判定の為、実際にそれぞれの結果を取得/変数保存するタイミングにずれがあり、その間に状態が変化すると、不整合状態になるのではと思う。
    - 対策は色々あると思うが「ある一つの判定処理内にて、両方を同時に使う事がないようにコードを組む」のが一番簡単だと思う。

- libgdxでは基本的に小数は全部floatなので、引数エラーになったら数値のうしろにfをつけたり、変数の前に(float)をつけたりしてみる。

- Preferences のデータの保存先
    - androidでは、androidのSharedPreferences内。
        - 仕様上では最大8kとなっているが、実質的には最大2k程度。
    - windowsでは、 `C:\Users\{USERNAME}\.prefs\{PREFNAME}\` 内。
        - androidとは違い、他のlibgdx利用アプリと共通なので、
          PREFNAMEはきちんとuniqueな名前にする必要がある！
    - windows以外のdesktopでは、 `~/.prefs/{PREFNAME}/` 内。
        - PREFNAMEについてはwindowsと同じ注意が必要！

- [assets]() にも少し関連情報を書いた

余裕があればチュートリアル的なものも書きたいが…そんな余裕はない！


<!-- vim:set ft=pandoc ts=4 sts=4 sw=4 et: -->
