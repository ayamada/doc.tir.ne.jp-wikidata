---
toc: yes
title: CLAN一時メモ
...

今のところ、完全に雑多なメモです。


# android関連

- 二回目起動時に、トップレベルのdefで定義した、以前に起動したプロセスの変数の内容が残っている。本体を起動するとなくなる
    - これはどうも、(android版)clojure固有の特性のようです。javaでは再現しない。
    - javaでは同じ問題が起こった時、単にstaticイニシャライザによって初期化されるだけなので、この現象は起こらないようだ。
        - [http://mobileapplication.blog.fc2.com/blog-entry-3.html]()
    - (android版)clojureでは、プロセス終了時に値を書き込み、staticイニシャライザが二回目起動時に読み込み直している？少なくともそれと同じ結果が起こっているように見える。
        - しかし本当にそうなのかはもっと調査が必要
    - この挙動が保証されたものであるなら便利に使えるが、そうでないなら利用するのは危険である。
        - androidのドキュメントおよびandroid版clojureのソースを調べる必要あり。

- 上記に関連して、二回目起動時にはロードされたクラスはキャッシュされる為、clojureの初期化は非常に早く終わる(PCよりも早い)。CLANいらないじゃん…。
    - なので、前述の現象が安全なもので、なおかつjava側からもこの現象を利用する方法があるなら、二回目起動時は起動画面をスキップするようにしたい(長いから)

- clojureでの動的コンパイル時に、以下のようなエラーを吐いて死ぬ時がある
    - `03-04 23:32:19.181: E/dalvikvm(4943): Can't open dex cache '/data/data/{package}/app_classes/repl-2128511998.dex': Too many open files`
    - 大きすぎるスクリプトをロードすると起こる？しかし同じスクリプトを読み込んでも再現する時としない時とがある


## プロファイルを取る

[http://labs.techfirm.co.jp/android/iguchi/2262]() を参考にした。

0. AndroidManifest.xml に以下がある事を確認

    ~~~
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    ~~~

0. `(import '(android.os Debug))` する(この段階でPCでは動かなくなるので注意)

0. create に以下を入れる

    ~~~
    (Debug/startMethodTracing "appname")
    ~~~

0. dispose に以下を入れる

    ~~~
    (Debug/stopMethodTracing)
    ~~~

0. `adb pull /mnt/sdcard/appname.trace .` もしくはmonitor.bat等でローカルにコピーする
    - sdcardのpathは違う可能性がある。以下で調べられる。

        ~~~
        (import '(android.os Environment))
        (.getPath (Environment/getExternalStorageDirectory))
        ~~~

0. monitor.bat のメニューの「File」→「Open File」から、 appname.trace を開いて内容を確認する。

どうもプロファイルが取れるのはcpu秒で数秒だけらしい。


## パフォーマンスチューニングメモ

### android & java

TODO: この部分についてはあちこちにノウハウがある筈。だが今の山田にはないのであとで集める。

### android & clojure

- [`*warn-on-reflection*`](http://clojure.org/java_interop#Java%20Interop-Type%20Hints) をつけて、警告をつぶす
    - 最重要。これをしないと実機でまともなパフォーマンスが出ない。

- dorun と doall は重い。loopとrecurにすべき
    - おそらくだが、clojureでは(無名)関数一つにつき一つのクラスが作られ、androidでは別クラスのmethod呼び出しはそこそこ高価なのが原因。
    - ただし doall を何も考えずに loop にすると、結果が逆順になる事に注意。

- defn じゃなく defmacro もしくは definline を使うとわずかにパフォーマンスが向上する。が、マクロとして書かないといけなくなるのでメンテ性が下がる。実行回数が非常に多い関数だけにすべき。
    - 実行回数が多いかどうかは前述のプロファイリングで調査…


# clojure関連

- clojureのマクロは、classファイルへコンパイルする場合は、そのコンパイル時にマクロが評価される事に注意が必要！classファイルのロード時とかではないので注意する(下手すると開発環境の値固定になってしまったりする)

- 別スレッドでevalがうごかないかもしれない。
    - 何故なら、evalをするにはneko.compilation/initを呼ぶ必要があるが、そこではvarにパラメータを保存している為。
    その場合は別スレッドでevalするまえにneko.compilation/initを呼ぶようにすれば動くと思うが、その際にディレクトリ指定はclasses以外にする事。
        - classesはCLANが利用するデフォルト値の為(MainActivity.javaから変更可)。neko.compilation/initは指定されたディレクトリを消すので、衝突すると多分動かなくなる

- android版clojureでは、definlineがマクロと同時に定義する関数の方は動かないっぽい？要調査


# java関連

- jarの仕様で、 assets 内のファイルもコンパイルしたファイルもいっしょくたに同じディレクトリに入れられてしまうので、これらの名前が衝突しないようにした方がいいです(いっしょくたになっても別にいいなら気にしなくてもいいですが…)。java sucks.
    - この為、clojureのパッケージであっても、java風の「jp.ne.example...」とか「com.example...」みたいなパッケージ名にした方がいいです。assets内に「jp」とか「com」とかのディレクトリを掘る事はまず無いと思うので。
    - またassets内にファイルを直置きせずに、ディレクトリを一段掘ってその中に入れるとよいでしょう。
    - 作ったjarが具体的にどういう構造になってるかは、 `jar tf path/to/xxx.jar` もしくは `mkdir hoge && cd hoge && jar xf path/to/xxx.jar` してみると確認できます。


# maven関連

## pom.xmlのディレクトリ区切り文字

- 正式には、 `${file.separator}` 。
    - 「/」でも大体問題はないが、windowsではapk生成等の一部でこけるので、その時はこれに直す事。

## clojure-maven-plugin のコンパイル対象認識

- ソースディレクトリ内に `*.clj` を置いていてもコンパイルされない時は、中のファイルの文字コードをシステム文字コードと一致させるか、環境変数MAVEN_OPTSに `-Dfile.encoding=utf-8` 的な指定を追加してみる。
    - これは、 clojure-maven-plugin が内部で使っている `org.codehaus.plexus.compiler.util.scan.*` あたりの仕様のようだ。


# はまりポイントまとめ
自分がはまった/はまりそうだったポイントのリストです。CLANと似た事を自分でもやってみようという人向け。

- jdkは1.6を用意。1.7は今のところandroid公式に非対応らしい。

- android上でclojureを動かす場合は、そのままでは動的コンパイルが動かないので、 [android/clojure](https://clojars.org/android/clojure) を入れた上で、 [neko.compilation/init](http://alexander-yakushev.github.com/neko/#neko.compilation) もしくはこれと同じ操作を実行する事。そしてこの操作を行う部分は必ずコンパイルしておく事。そうしないと缶切りが缶詰の中にある状態になってしまう。

- dexファイル形式の制約により、一つのdexファイルに含める事のできるメンバ参照数やクラス数やメソッド数には上限があるらしい。
    - [http://b.hatena.ne.jp/entry/groups.google.com/group/android-platform/browse_thread/thread/b592834502a1b69a]() scalaでは上限に引っかかったらしい
    - 自分で実際にCLAN生成物から測定してみたところ、clojure-1.5.0が5016クラス、libgdx-0.9.7が729クラス、dx.jarが456クラス、nekoが362クラスあった。クラス数は当分大丈夫そうだが、メンバ参照数も大丈夫かはちょっと分からない。
        - 上限に引っかかったらdexコンパイル時にエラーが出るようなので、そうなってから対策を考える。
    - あくまでdexファイル上での制限で、プロセス起動後に動的に追加する分にはこの問題はないようだ

- PC環境とは違い、androidでは二回目起動時に、メインアクティビティのクラス以外は`<clinit>`が実行されず、前回起動時の状態が残るっぽい？(未確定、もうちょっと条件の調査が必要…)
    - android実機を再起動すると消える、他にも消える条件があるかも
    - とりあえずclojureでloadやevalした結果は明示的に初期化しなおさない限り前回のが残ってしまうので、初期化管理は`<clinit>`等に頼らずに、明示的に行った方がいい(この件に限らず、GLコンテキストの喪失問題とかもあるので)

- ビルド番号の埋め込み手法どうするか
    - 通常のjavaであれば、 `META-INF/MANIFEST.MF` あたりに埋め込むようだが…

あとは思い出し次第追加します。


<!-- vim:set ft=pandoc ts=4 sts=4 sw=4 et: -->
