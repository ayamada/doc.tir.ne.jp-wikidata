---
toc: yes
title: CLAN一時メモ
...

今のところ、完全に雑多なメモです。


# android関連

基本的には [libgdx]() の方に書く。ここにはandroid版clojure固有の問題だけ書く。

- clojureでの動的コンパイル(eval)時に、以下のようなエラーを吐いて死ぬ時がある
    - `03-04 23:32:19.181: E/dalvikvm(4943): Can't open dex cache '/data/data/{package}/app_classes/repl-2128511998.dex': Too many open files`
    - 大きすぎるスクリプトをロードすると起こる？しかし同じスクリプトを読み込んでも再現する時としない時とがある

- プロジェクトのサイズが大きくなると、dxコンパイルに失敗する時がある。その時は、 android/pom.xml.in の `<jvmArgument>-Xmx1024m</jvmArgument>` を適当に増やしてから autoconf しなおす。

- 一つの関数(method)があまりにも大きくなりすぎると、`No free temp registers` `Jit: aborting trace compilation, reverting to interpreter` というログを出して動作がおかしくなる
    - このエラーメッセージを見る限りでは「空きレジスタなくなったからJITコンパイルするのやめてインタプリタ動作に切り替えるよ」という内容で、ぐぐった結果も「無害」となっていたが、これが出はじめると(多分)floatの数値計算系の結果が狂うようになった。dalvik vmのバグを踏んだか？
    - 出る条件は、一つの関数(method)内で大量のコードがある、か、letで変数を確保しすぎた、かのどちらか(詳細未調査)。とりあえず適当に関数を分割すれば対応可能。

- `shutdown-agents` は実行してはならない。実行したら二回目実行時にagent系が全滅するようになる。


## プロファイルを取る

追記: 以下をやらなくても、monitorのDevicesのところからプロセスを選択して、「Start method profiling」「Stop method profiling」で取得可能だった。

----

[http://labs.techfirm.co.jp/android/iguchi/2262]() を参考にした。

0. AndroidManifest.xml に以下がある事を確認

    ~~~
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    ~~~

0. `(import '(android.os Debug))` する(この段階でPCでは動かなくなるので注意)

0. create に以下を入れる

    ~~~
    (Debug/startMethodTracing "appname")
    ~~~

0. dispose に以下を入れる

    ~~~
    (Debug/stopMethodTracing)
    ~~~

0. `adb pull /mnt/sdcard/appname.trace .` もしくはmonitor.bat等でローカルにコピーする
    - sdcardのpathは違う可能性がある。以下で調べられる。

        ~~~
        (import '(android.os Environment))
        (.getPath (Environment/getExternalStorageDirectory))
        ~~~

0. monitor.bat のメニューの「File」→「Open File」から、 appname.trace を開いて内容を確認する。

どうもプロファイルが取れるのはcpu秒で数秒だけらしい。


## パフォーマンスチューニングメモ

### android & java

TODO: この部分についてはあちこちにノウハウがある筈。だが今の山田にはないのであとで集める。

### android & clojure

- [`*warn-on-reflection*`](http://clojure.org/java_interop#Java%20Interop-Type%20Hints) をつけて、警告をつぶす
    - 最重要。これをしないと実機でまともなパフォーマンスが出ない。

- dorun と doall は重い。loopとrecurにすべき
    - おそらくだが、clojureでは(無名)関数一つにつき一つのクラスが作られ、androidでは別クラスのmethod呼び出しはそこそこ高価なのが原因。
    - ただし doall を何も考えずに loop にすると、結果が逆順になる事に注意。
    - loopとrecurでも重い場合(遅延シーケンスのrestが重い？)は、もうjava arrayとdotimesにすべき。関数型でも何でもない…。

- defn じゃなく defmacro もしくは definline を使うとわずかにパフォーマンスが向上する。が、マクロとして書かないといけなくなるのでメンテ性がかなり下がる。実行回数が非常に多い関数だけにすべき。
    - 実行回数が多いかどうかは前述のプロファイリングで調査…
    - マクロにした場合のデメリット
        - 「動いてるプロセスにアタッチして特定関数だけ差し替える」操作が、マクロ化してしまうと直接にはできなくなる
            - 特定関数だけと言わず全部リロードしてしまえば大丈夫ではあるが…
        - スタックトレースに表示されなくなるので追跡が困難に


# clojure関連

- clojureのマクロは、classファイルへコンパイルする場合は、そのコンパイル時にマクロが評価される事に注意が必要！classファイルのロード時とかではないので注意する
    - 下手すると開発環境の値固定になってしまったりする

- 別スレッドでevalがうごかないかもしれない。
    - 何故なら、evalをするにはneko.compilation/initを呼ぶ必要があるが、そこではvarにパラメータを保存している為。
    その場合は別スレッドでevalするまえにneko.compilation/initを呼ぶようにすれば動くと思うが未確認。
        - もしneko.compilation/initが古いdexキャッシュを消す挙動をする場合、第二引数として適当なディレクトリ名を与える必要がありそう。

- android版clojureでは、definlineがマクロと同時に定義する関数の方は動かないっぽい？要調査
    - applyしたら動かなかった時があった気がする


# maven関連

## pom.xmlのディレクトリ区切り文字

- 正式には、 `${file.separator}` 。
    - 「/」でも大体問題はないが、windowsではapk生成等の一部でこけるので、その時はこれに直す事。

## clojure-maven-plugin のコンパイル対象認識

- ソースディレクトリ内に `*.clj` を置いていてもコンパイルされない時は、中のファイルの文字コードをシステム文字コードと一致させるか、環境変数MAVEN_OPTSに `-Dfile.encoding=utf-8` 的な指定を追加してみる。
    - これは、 clojure-maven-plugin が内部で使っている `org.codehaus.plexus.compiler.util.scan.*` あたりの仕様のようだ。

## 配布物のjarにcalのソースファイルを含めないようにするには
- 以下のように、 `cal/pom.xml.in` にてexclude指定を行う。
    - ただしこの指定を行うと `*warn-on-reflection*` が有効な時にエラーが出てしまう為、リリース時にのみこの設定を行うようにすべき。

~~~
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <excludes><exclude>**/*.clj</exclude></excludes>
        </configuration>
      </plugin>
~~~

# はまりポイントまとめ
自分がはまった/はまりそうだったポイントのリストです。CLANと似た事を自分でもやってみようという人向け。

- jdkは1.6を用意。1.7は今のところandroid公式に非対応らしい。

- android上でclojureを動かす場合は、そのままでは動的コンパイルが動かないので、 [android/clojure](https://clojars.org/android/clojure) を入れた上で、 [neko.compilation/init](http://alexander-yakushev.github.com/neko/#neko.compilation) もしくはこれと同じ操作を実行する事。そしてこの操作を行う部分は必ずコンパイルしておく事。そうしないと缶切りが缶詰の中にある状態になってしまう。

- dexファイル形式の制約により、一つのdexファイルに含める事のできるメンバ参照数やクラス数やメソッド数には上限があるらしい。
    - [http://b.hatena.ne.jp/entry/groups.google.com/group/android-platform/browse_thread/thread/b592834502a1b69a]() scalaでは上限に引っかかったらしい
    - 自分で実際にCLAN生成物から測定してみたところ、clojure-1.5.0が5016クラス、libgdx-0.9.7が729クラス、dx.jarが456クラス、nekoが362クラスあった。クラス数は当分大丈夫そうだが、メンバ参照数も大丈夫かはちょっと分からない。
        - 上限に引っかかったらdexコンパイル時にエラーが出るようなので、そうなってから対策を考える。
    - あくまでdexファイル上での制限で、プロセス起動後に動的に追加する分にはこの問題はないようだ

- [libgdx#androidのdexキャッシュ問題]()

- ビルド番号の埋め込み手法どうするか
    - 通常のjavaであれば、 `META-INF/MANIFEST.MF` あたりに埋め込むようだが…

あとは思い出し次第追加します。


<!-- vim:set ft=pandoc ts=4 sts=4 sw=4 et: -->
